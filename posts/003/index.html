<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OS_FinalExam 筆記 | Shu's Blog</title><meta name=keywords content="OS,NOTE"><meta name=description content="作業系統期末單元整理."><meta name=author content="Shu"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.03829ba7190005932d2a6894949395b492ef1b291ef714baa0c0ba04e7efe976.css integrity="sha256-A4KbpxkABZMtKmiUlJOVtJLvGyke9xS6oMC6BOfv6XY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://forshu.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://forshu.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://forshu.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://forshu.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://forshu.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.102.3"><meta property="og:title" content="OS_FinalExam 筆記"><meta property="og:description" content="作業系統期末單元整理."><meta property="og:type" content="article"><meta property="og:url" content="https://forshu.com/posts/003/"><meta property="article:section" content="posts"><meta property="og:site_name" content="Shu's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="OS_FinalExam 筆記"><meta name=twitter:description content="作業系統期末單元整理."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://forshu.com/posts/"},{"@type":"ListItem","position":3,"name":"OS_FinalExam 筆記","item":"https://forshu.com/posts/003/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OS_FinalExam 筆記","name":"OS_FinalExam 筆記","description":"作業系統期末單元整理.","keywords":["OS","NOTE"],"articleBody":"OS 期末筆記 單元重點\nchap5 CPU scheduling 目的：最大化 cpu 使用率，主要由 short-term scheduler 負責 process 之 execution 通常包括 CPU execution(cpu burst time) and I/O wait(i/o burst time) 4種 Cpu scheduling 時機 1\u00264 不能中斷(nonpreemptive) 2\u00263 可以中斷(preemptive)\nrunning-\u003ewaiting (I/O 請求) running-\u003eready (time out、interrupt) waiting-\u003eready (I/O 完成) //高優先權變 ready process terminates nonpreemptive(不可插隊)：若 process 不釋放 CPU 使用權,無法被強迫中斷(自願釋放 CPU) preemptive(可插隊)：若 process 不釋放 CPU 使用權,可以被強迫中斷(被迫放棄 CPU) Dispatcher 功能 // def:真正分派 CPU 給 process\ncontext switching 切換至 user mode 跳至使用者程式的位置繼續執行 Dispatch latency(分派延遲)：Dispatchr 結束一個 process，並開始另一個 process 之執行所花的時間(越短越好) cpu scheduling criteria(準則) CPU 使用率(utilization):CPU 越忙越好 產能(Throughput)：單位時間內可完成的 process 數量，越多越好 整體執行時間(Turnaround time)：從 process 進入系統開始至離開系統(完成工作)為止，越短越好 t.t = b.t + w.t 等候時間(Waiting time)：一個 process 在 ready queue 等待取得 CPU 的時間加總，越短越好 回覆時間(Response time)：一個 request 發出後，至第一個回覆收到所花的時間，越短越好 CPU scheduling algo FCFS(FIFO)\n特性:\n排班效能差 平均等待時間長 會遭遇 convoy effect(護衛效應)：較短之 cpu time process 必須等較長之 cpu time process 完成工作，導致 cpu 使用率降低，平均等待時間長 no starvaion(不飢餓)：低優先權 process 遲遲無法完工，因為無法取得完工所需資源) //有機會完工 SJF\n特性:\n排班效能最佳 可能會 starvation 很難預測下一次 cpu burst time preemptive sjf(SRTF)(shortest remaining time first)\nRR(Round Robin)\n特性:\n為 time-sharing 所設計的 類似 FCFS，但加上 preemptive 任一 process 最多的等候時間將不會超過(n-1)*q 之時間 q 太大=\u003eFCFS q 太小=\u003econtext switching 負擔高 priority\n特性:\n可能會 starvation，用 aging(老化)解決:每隔一段時間，可將系統內等待 process 的優先權提升一級\nmultilevel queue\n前景佇列：採 RR (Round Robin) 背景佇列：採 FCFS (First Come First Served) Queue 之間採用:固定優先權強佔排程(Fixed-priority preemptive scheduling) multilevel feedback queue\nThread scheduling Multiple processor scheduling(多處理器)\n非對稱多處理機系統(Asymmetric multiprocessing):所有排程決定、I/O 處理、及其他系統運作，均由一個處理器(即 master server)掌控，其他處理器只負責執行使用者程式(user code) 對稱式多處理機系統(Symmetric multiprocessing，SMP):每一個處理器各自排程，所有 process 可置於同一個共用的 ready queue，或每一個處理器有各自的 ready queue 對稱式:\nProcessor affinity (親和性) – 保持一個 process 在相同的處理器上執行稱之 軟親和(Soft affinity)：prcoess 有可能轉移 硬親和(Hard affinity)：process 不會有移轉問題 在對稱式系統中，負載平衡(load balancing)企圖保持工作均勻的分散在所有處理器。負載平衡的方法：\n推出移轉 (Push migration):週期性檢查每個處理器負載，若發現不平衡，則將過度負載的處理器平均將行程分散到閒置或較不忙的處理器 引入移轉 (Pull migration):一個閒置或工作較輕的處理器，由忙碌的處理器拉一個正在等候的 process real-time sys\n硬性即時系統(hard real-time system)：嚴格限制作業必須在要求的截止期限內完成，絕不可逾期 軟性即時系統(soft real-time system)：保證高優先權的 Process 必須先於所有低優先權的 Process 完成，但不確保何時進行 scheduling 會影響即時系統效能的兩種延遲時間：\n中斷延遲時間(Interrupt latency)： 從中斷到達 CPU 至中斷服務常式啟動所需之時間 分派延遲時間(Dispatch latency)： 排程分派程式結束一行程至開始另一行程所需時間 優先權反轉(priority inversion)：高優先權之 process 等待低優先權 process 釋放其所需之資源，但低優先權 process 無法在短時間取得 cpu，造成高優先權 process 等待時間大幅增加。\n解法:優先權繼承 讓低優先權 process 先繼承高優先權 process 之權值，讓低優先權 process 取得 cpu 執行，讓高優先權之 process 可取得資源，再回復原本低優先權權值之權值\nchap 6 Synchronization Race condition 多個 process 同時使用共享變數，則可能導致共享變數最終值可能會因為 process 之間的交錯執行而有不同之結果。 ·\nMutual Exclusion(互斥)：有 process 在 critical section 裡面其他 prcoess 就不可以進去。 Progress(前進)：沒有 process 在 critical section 裡面時，而且有 process 想進 critical section，必須在有限時間內決定誰可以進去，不可造成所有 process 都進不去。 Bounded Waiting(有限等待)：在一個 process 發出進入 critical section 請求之後，且在該請求被允許之前，其他 process 進入其 critical section 的次數必須有一個限制 軟體 Peterson 解決方式(2 processes) Bakery Algorithm(N prcoesses Peterson) 硬體 memory barries:memory 內容改變必須讓 prcoessors 知道 HW instructions:系統直接提供具有 Atomic 特性的指令，讓程式碼可以在單一時間點被完成，且不會中途被插斷。(Atomically Executed:在單位時間內可以順利做完，不受任何中斷干擾) test-and-set swap Mutex locks(互斥鎖)(spinlock) 在進入臨界區之前先獲得 Mutex locks，離開臨界區時再釋放 Mutex locks 即可\nSemaphore(號誌) 用來解決 C.S. Design 及同歩問題的一種資料型態。\nwait(S) { while (S \u003c= 0); S--; } signal(S) { S++; } chap 8 Deadlock Deadlock def 系統中存在一組 process 陷入互相等待對方所擁有的資源的情況，造成所有的 process 無法往下執行，使得 CPU 利用度大幅降低。\n死結四個必要條件 少一死結不成立\n互斥(Mutual exclusion)：一次只有一個 process 可以使用此資源 擁有與等待(Hold and wait)：擁有至少一個資源的 process 正在等待獲取其他 process 所擁有的其他資源 不能強佔(No preemption)：擁有此資源的 process 完成工作後，才自動將此資源釋放出來 循環等待(Circular wait)：系統中存在一組 processes {P0,P1,…,Pn}，其中 P0 等待 P1 所持有的資源…Pn 等待 P0 所持有的資源，形成循環式等待。 資源分配圖 有圈圈有可能有死結，如果每一種資源型態都只有一個設備，則一定產生死結，複數個設備，則不一定會產生死結。沒圈圈沒有死結\n請求邊(request edge)：有向邊 Pi-\u003eRj 代表 proceess Pi 對資源型態 Rj 的設備發出使用請求 分配邊(assignment edge)：有向邊 Rj-\u003ePi 代表資源型態 Rj 的一項設備已經分配給 process Pi 死結處理方法 死結預防(deadlock prevention):讓四個必要條件至少有一個不成立\n互斥(Mutual exclusion):但對不可共享的資源則一定成立，通常 read only file 是分享式資源\n擁有與等待(Hold and wait):\n除非 process 可以一次取得所有工作所需的資源，才允許持有資源 process 執行之初可持有部分資源，但要再申請資源前，要先釋放手中所有資源 缺點:資源使用率低、可能發生 starvation\n不能強佔(No preemption):讓 process 手上的資源是允許被其它程式搶走的 循環等待(Circular wait):將所有資源型態作一順序性的編號，並要求所有行程依遞增(減)方式來請求資源 死結避免(deadlock avoidance): 最簡單及最有用的作法，即要求每一行程提供它所需要的各種資源型態的最大需求量(maximum number)死結避免演算法將動態檢驗資源分配狀態，確保循環等待(circular-wait)的條件不會發生資源分配狀態是由資源的可用量、已分配量、及 process 最大需求量來定義。\nsafe state： 當程式提出資源的申請時，透過一個叫做「Banker’s algorithm」的演算法檢查程式是否會進入「unsafe state」，safe state 是絕對不可能發生 deadlock 的情形，unsafe state 是有可能發生 deadlock 的情形，若允許程式提出資源的申請會進入「unsafe state」，便拒絕該程式的申請。 死結避免演算法 銀行家演算法 (Banker’s algorithm)\n資料結構:\n可用資源陣列(Available)\n最大需求陣列(Max)\n已分配陣列(Allocation)\n剩餘需求陣列(Need)need = max-allocation\nrequest\u003c=need 成立 goto2. request\u003c=available 成立 goto3 available = available - request allocation = allocation + request need = need - request 成立 goto4 執行 safety algo\n新增資料結構: Work Finish 求出一個安全的序列\n資源分配圖形演算法 (Resource-allocation-graph algorithm)\n死結偵測與回復(deadlock detection \u0026 recovery)\nchap9 Main Memory base 與 limit 暫存器可用來界定 address space\n程式指令、資料與記憶體的位址連結(address binding)(決定 process 執行在 memory 之起始位置)可以發生在 3 個不同的階段：\n編譯時期(Compile time)：如果記憶體的位置是已知，編譯器產生具絕對位址的絕對碼(absolute code)，往後如果位置改變，則程式需重新編譯(recompile) 載入時期(Load time)：如果記憶體的位置為未知，則編譯器需產生可重定位之程式碼(relocatable code) 執行時期(Execution time)：若行程在執行期間會從記憶體的某一區段(segment)移至另一區段時，則位址連結將延後至執行時期處理。(base 與 limit 暫存器) 邏輯位址(Logical address) CPU 所產生的位址稱之，也叫做虛擬位址(virtual address)\n實體位址(Physical address) 記憶體單元所看到的位址，真正記憶體的位置(就是載入到記憶體位址暫存器(MAR)之地址)\n程式執行時虛擬(邏輯)位址與實體位址的 mapping，需藉由記憶體管理單元(Memory-Management Unit，MMU)的硬體來完成\ndynamic loading(動態載入)：常式(routine)通常是在被呼叫時才載入\n優點:為了讓記憶體空間做最好的利用 缺點:較不具效率 (不需要 OS support) Dynamic linking(動態鏈結)：類似動態載入，且將鏈結延後至執行時間\n優點:也叫 shared library，因為 library 可以共用 (需要 OS support) 先做 linking 再做 loading，所以 loading 前一定會先有 linking。linking 顧名思義就是與其他東西做連結，像是與 library 或者你程式有使用到別的程式的部分。\nDynamic loading 的目標是“函式沒有用到就不要 load”，Dynamic linking 的目標 則是防止重複 load library。\n前者未必能防止重複，而後者需要檢查其他 process space，所以需要 OS 才能做到。\n連續記憶體配置(contiguous allocation):因為 process 載入到 memory 執行，需要一塊連續的 memory space\nmemory protect base register 包含最小物理地址的值 limit register 包含邏輯地址範圍，每個邏輯地址必須小於 limit register memory allocation 多重分區 (Multiple-partition)分配:\npartition:(因為 process 載入到 memory 執行，需要一塊連續的 memory space)，即是 process 數目 partition size:也稱 varaiable partition，因為每個 process 大小不同 hole:process 多次的配置與釋放後，會有一些空間 free 如何從 list of free holes 找出滿足記憶體大小需求為 n 的請求?\nFirst-fit:分配第一個夠大的 hole 給 process Best-fit:在足夠大的 hole 裡面找出最小的 hole Worst-fit:在足夠大的 hole 給他最大的 hole 1 ,2 \u003e 3 但連續記憶體配置會遭遇一個問題：External Fragmentation Fragmentation(碎裂) External Fragmentation(外部碎裂):memory space 加起來夠大，但卻不連續，導致無法分配 Internal Fragmentation(內部碎裂):分配的 memory space 比實際需求還大所造成的浪費，且這些空間不能再被使用 解決外碎\ncompation(壓縮) paging(分頁) paging 對實體位址空間採用非連續性配置 解決外碎，但還是有內碎 page table 太大或建構方法 Multilevel paging Hashing Page Table Invert Page Table chap 10 Virtual Memory VM 一種允許行程執行時，不須完全載入記憶體的做法\n優點：程式可以大於實體記憶體 logical address space 可以大過 physical address space 缺點:不容易實作，可能會降低效能\n邏輯位址空間可以遠大於實體記憶體空間 multiprogramming degree 增加 I/O time 減少 實作 VM 需求分頁(Demand paging)：於實際需要時才載入 pages\n在分頁表中每一項目均有一個有效/無效位元(valid/invalid bit) (v 表分頁在記憶體內，i 表分頁不在記憶體內) 當分頁不在記憶體內時(bit = i)，發生 page fault 需求分段(Demand segmentation)：於實際需要時才載入 segmentation\npage fault handling 決定是否為合法/非法的記憶體存取 非法:終止這個 process，合法:page 不再記憶體 尋找可用頁框(free frame) 讀取 page 到可用頁框 修改 page table 重新執行導致 page fault 的指令 分頁有效存取時間 (Effective Access Time) 之計算 EAT = (1-p) Memory Access Time + p (Page fault process time) p 是 page fault ratio. 例: page fault ratio = 20%， Memory Access Time=100ns, Page fault process time = 5ns =\u003e(1-0.2)100 + 0.25 = 9\npage replacement algo FIFO OPT LRU Belady’s anomaly：分配給 process 的頁框數增加，理應 page fault 次數應該降低，但 page fault ratio 卻不減反升 Thrashing(振盪) 當 CPU 效能低時，系統會想引入更多的 process 讓 CPU 盡可能地工作(multiprogramming degree)。但當存有太多 process 時，大部分的工作將會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 的效能越來越低。\n方法 降低 Multiprogramming Degree。 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數，以防止 Thrashing。 copy-on-write OS 會配置一個 new frame 給 child，將 page 內容 copy 一份到 new frame，修改 child 之 page table 指向 new frame 後，child 才進行 write 動作。\n優點：減少記憶體占用、增加 process 的 creation 速度 ","wordCount":"880","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Shu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://forshu.com/posts/003/"},"publisher":{"@type":"Organization","name":"Shu's Blog","logo":{"@type":"ImageObject","url":"https://forshu.com/favicon.ico"}}}</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+Display:wght@500&display=swap" rel=stylesheet></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://forshu.com accesskey=h title="Shu's Blog (Alt + H)">Shu's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://forshu.com/posts/ title=首頁><span>首頁</span></a></li><li><a href=https://forshu.com/archives/ title=歸檔><span>歸檔</span></a></li><li><a href=https://forshu.com/categories/ title=類別><span>類別</span></a></li><li><a href=https://forshu.com/tags/ title=標籤><span>標籤</span></a></li><li><a href=https://forshu.com/search/ title="搜尋 (Alt + /)" accesskey=/><span>搜尋</span></a></li><li><a href=https://forshu.com/about/ title=關於><span>關於</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://forshu.com>Home</a>&nbsp;»&nbsp;<a href=https://forshu.com/posts/>Posts</a></div><h1 class=post-title>OS_FinalExam 筆記</h1><div class=post-description>作業系統期末單元整理.</div><div class=post-meta>5 min&nbsp;·&nbsp;Shu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#os-%e6%9c%9f%e6%9c%ab%e7%ad%86%e8%a8%98 aria-label="OS 期末筆記">OS 期末筆記</a><ul><li><a href=#chap5 aria-label=chap5>chap5</a><ul><li><a href=#4%e7%a8%ae-cpu-scheduling-%e6%99%82%e6%a9%9f aria-label="4種 Cpu scheduling 時機">4種 Cpu scheduling 時機</a></li><li><a href=#dispatcher-%e5%8a%9f%e8%83%bd aria-label="Dispatcher 功能">Dispatcher 功能</a></li><li><a href=#cpu-scheduling-criteria%e6%ba%96%e5%89%87 aria-label="cpu scheduling criteria(準則)">cpu scheduling criteria(準則)</a></li><li><a href=#cpu-scheduling-algo aria-label="CPU scheduling algo">CPU scheduling algo</a></li><li><a href=#thread-scheduling aria-label="Thread scheduling">Thread scheduling</a></li></ul></li><li><a href=#chap-6-synchronization aria-label="chap 6 Synchronization">chap 6 Synchronization</a><ul><li><a href=#race-condition aria-label="Race condition">Race condition</a></li><li><a href=#%e8%bb%9f%e9%ab%94 aria-label=軟體>軟體</a></li><li><a href=#%e7%a1%ac%e9%ab%94 aria-label=硬體>硬體</a></li><li><a href=#mutex-locks%e4%ba%92%e6%96%a5%e9%8e%96spinlock aria-label="Mutex locks(互斥鎖)(spinlock)">Mutex locks(互斥鎖)(spinlock)</a></li><li><a href=#semaphore%e8%99%9f%e8%aa%8c aria-label=Semaphore(號誌)>Semaphore(號誌)</a></li></ul></li><li><a href=#chap-8-deadlock aria-label="chap 8 Deadlock">chap 8 Deadlock</a><ul><li><a href=#deadlock-def aria-label="Deadlock def">Deadlock def</a></li><li><a href=#%e6%ad%bb%e7%b5%90%e5%9b%9b%e5%80%8b%e5%bf%85%e8%a6%81%e6%a2%9d%e4%bb%b6 aria-label=死結四個必要條件>死結四個必要條件</a></li><li><a href=#%e8%b3%87%e6%ba%90%e5%88%86%e9%85%8d%e5%9c%96 aria-label=資源分配圖>資源分配圖</a></li><li><a href=#%e6%ad%bb%e7%b5%90%e8%99%95%e7%90%86%e6%96%b9%e6%b3%95 aria-label=死結處理方法>死結處理方法</a></li><li><a href=#%e6%ad%bb%e7%b5%90%e9%81%bf%e5%85%8d%e6%bc%94%e7%ae%97%e6%b3%95 aria-label=死結避免演算法>死結避免演算法</a></li></ul></li><li><a href=#chap9-main-memory aria-label="chap9 Main Memory">chap9 Main Memory</a><ul><li><a href=#%e9%82%8f%e8%bc%af%e4%bd%8d%e5%9d%80logical-address aria-label="邏輯位址(Logical address)">邏輯位址(Logical address)</a></li><li><a href=#%e5%af%a6%e9%ab%94%e4%bd%8d%e5%9d%80physical-address aria-label="實體位址(Physical address)">實體位址(Physical address)</a></li><li><a href=#memory-protect aria-label="memory protect">memory protect</a></li><li><a href=#memory-allocation aria-label="memory allocation">memory allocation</a></li><li><a href=#fragmentation%e7%a2%8e%e8%a3%82 aria-label=Fragmentation(碎裂)>Fragmentation(碎裂)</a></li><li><a href=#paging aria-label=paging>paging</a></li><li><a href=#page-table-%e5%a4%aa%e5%a4%a7%e6%88%96%e5%bb%ba%e6%a7%8b%e6%96%b9%e6%b3%95 aria-label="page table 太大或建構方法">page table 太大或建構方法</a></li></ul></li><li><a href=#chap-10-virtual-memory aria-label="chap 10 Virtual Memory">chap 10 Virtual Memory</a><ul><li><a href=#vm aria-label=VM>VM</a></li><li><a href=#%e5%af%a6%e4%bd%9c-vm aria-label="實作 VM">實作 VM</a></li><li><a href=#page-fault-handling aria-label="page fault handling">page fault handling</a></li><li><a href=#%e5%88%86%e9%a0%81%e6%9c%89%e6%95%88%e5%ad%98%e5%8f%96%e6%99%82%e9%96%93-effective-access-time-%e4%b9%8b%e8%a8%88%e7%ae%97 aria-label="分頁有效存取時間 (Effective Access Time) 之計算">分頁有效存取時間 (Effective Access Time) 之計算</a></li><li><a href=#page-replacement-algo aria-label="page replacement algo">page replacement algo</a></li><li><a href=#thrashing%e6%8c%af%e7%9b%aa aria-label=Thrashing(振盪)>Thrashing(振盪)</a></li><li><a href=#copy-on-write aria-label=copy-on-write>copy-on-write</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=os-期末筆記>OS 期末筆記<a hidden class=anchor aria-hidden=true href=#os-期末筆記>#</a></h2><p>單元重點</p><h3 id=chap5>chap5<a hidden class=anchor aria-hidden=true href=#chap5>#</a></h3><ul><li>CPU scheduling 目的：最大化 cpu 使用率，主要由 short-term scheduler 負責</li><li>process 之 execution 通常包括 CPU execution(cpu burst time) and I/O wait(i/o burst time)</li></ul><h4 id=4種-cpu-scheduling-時機>4種 Cpu scheduling 時機<a hidden class=anchor aria-hidden=true href=#4種-cpu-scheduling-時機>#</a></h4><blockquote><p><strong>1&4 不能中斷(nonpreemptive) 2&3 可以中斷(preemptive)</strong></p><ol><li>running->waiting (I/O 請求)</li><li>running->ready (time out、interrupt)</li><li>waiting->ready (I/O 完成) //高優先權變 ready</li><li>process terminates</li></ol></blockquote><ul><li>nonpreemptive(不可插隊)：若 process 不釋放 CPU 使用權,無法被強迫中斷(自願釋放 CPU)</li><li>preemptive(可插隊)：若 process 不釋放 CPU 使用權,可以被強迫中斷(被迫放棄 CPU)</li></ul><h4 id=dispatcher-功能>Dispatcher 功能<a hidden class=anchor aria-hidden=true href=#dispatcher-功能>#</a></h4><p>// def:真正分派 CPU 給 process</p><blockquote><ol><li>context switching</li><li>切換至 user mode</li><li>跳至使用者程式的位置繼續執行</li></ol></blockquote><ul><li>Dispatch latency(分派延遲)：Dispatchr 結束一個 process，並開始另一個 process 之執行所花的時間(越短越好)</li></ul><h4 id=cpu-scheduling-criteria準則>cpu scheduling criteria(準則)<a hidden class=anchor aria-hidden=true href=#cpu-scheduling-criteria準則>#</a></h4><ol><li>CPU 使用率(utilization):CPU 越忙越好</li><li>產能(Throughput)：單位時間內可完成的 process 數量，越多越好</li><li>整體執行時間(Turnaround time)：從 process 進入系統開始至離開系統(完成工作)為止，越短越好 t.t = b.t + w.t</li><li>等候時間(Waiting time)：一個 process 在 ready queue 等待取得 CPU 的時間加總，越短越好</li><li>回覆時間(Response time)：一個 request 發出後，至第一個回覆收到所花的時間，越短越好</li></ol><h4 id=cpu-scheduling-algo>CPU scheduling algo<a hidden class=anchor aria-hidden=true href=#cpu-scheduling-algo>#</a></h4><ol><li><p>FCFS(FIFO)</p><p><strong>特性:</strong></p><ul><li>排班效能差</li><li>平均等待時間長</li><li>會遭遇<ul><li>convoy effect(護衛效應)：較短之 cpu time process 必須等較長之 cpu time process 完成工作，導致 cpu 使用率降低，平均等待時間長</li><li>no starvaion(不飢餓)：低優先權 process 遲遲無法完工，因為無法取得完工所需資源) //有機會完工</li></ul></li></ul></li><li><p>SJF</p><p><strong>特性:</strong></p><ul><li>排班效能最佳</li><li>可能會 starvation</li><li>很難預測下一次 cpu burst time</li></ul></li><li><p>preemptive sjf(SRTF)(shortest remaining time first)</p></li><li><p>RR(Round Robin)</p><p><strong>特性:</strong></p><ul><li>為 time-sharing 所設計的</li><li>類似 FCFS，但加上 preemptive
任一 process 最多的等候時間將不會超過(n-1)*q 之時間<ul><li>q 太大=>FCFS</li><li>q 太小=>context switching 負擔高</li></ul></li></ul></li><li><p>priority</p><p><strong>特性:</strong></p><p>可能會 starvation，用 aging(老化)解決:每隔一段時間，可將系統內等待 process 的優先權提升一級</p></li><li><p>multilevel queue</p><ul><li>前景佇列：採 RR (Round Robin)</li><li>背景佇列：採 FCFS (First Come First Served)</li><li>Queue 之間採用:固定優先權強佔排程(Fixed-priority preemptive scheduling)</li></ul></li><li><p>multilevel feedback queue</p></li></ol><h4 id=thread-scheduling>Thread scheduling<a hidden class=anchor aria-hidden=true href=#thread-scheduling>#</a></h4><ul><li><p>Multiple processor scheduling(多處理器)</p><ol><li>非對稱多處理機系統(Asymmetric multiprocessing):所有排程決定、I/O 處理、及其他系統運作，均由一個處理器(即 master server)掌控，其他處理器只負責執行使用者程式(user code)</li><li>對稱式多處理機系統(Symmetric multiprocessing，SMP):每一個處理器各自排程，所有 process 可置於同一個共用的 ready queue，或每一個處理器有各自的 ready queue</li></ol></li><li><p>對稱式:</p><ul><li>Processor affinity (親和性) – 保持一個 process 在相同的處理器上執行稱之</li><li>軟親和(Soft affinity)：prcoess 有可能轉移</li><li>硬親和(Hard affinity)：process 不會有移轉問題</li></ul></li><li><p>在對稱式系統中，負載平衡(load balancing)企圖保持工作均勻的分散在所有處理器。負載平衡的方法：</p><ol><li>推出移轉 (Push migration):週期性檢查每個處理器負載，若發現不平衡，則將過度負載的處理器平均將行程分散到閒置或較不忙的處理器</li><li>引入移轉 (Pull migration):一個閒置或工作較輕的處理器，由忙碌的處理器拉一個正在等候的 process</li></ol></li><li><p>real-time sys</p><ol><li>硬性即時系統(hard real-time system)：嚴格限制作業必須在要求的截止期限內完成，絕不可逾期</li><li>軟性即時系統(soft real-time system)：保證高優先權的 Process 必須先於所有低優先權的 Process 完成，但不確保何時進行 scheduling</li></ol></li></ul><blockquote><p>會影響即時系統效能的兩種延遲時間：</p><ol><li>中斷延遲時間(Interrupt latency)：
從中斷到達 CPU 至中斷服務常式啟動所需之時間</li><li>分派延遲時間(Dispatch latency)：
排程分派程式結束一行程至開始另一行程所需時間</li></ol></blockquote><ul><li><p>優先權反轉(priority inversion)：高優先權之 process 等待低優先權 process 釋放其所需之資源，但低優先權 process 無法在短時間取得 cpu，造成高優先權 process 等待時間大幅增加。</p></li><li><p>解法:優先權繼承
讓低優先權 process 先繼承高優先權 process 之權值，讓低優先權 process 取得 cpu 執行，讓高優先權之 process 可取得資源，再回復原本低優先權權值之權值</p></li></ul><h3 id=chap-6-synchronization>chap 6 Synchronization<a hidden class=anchor aria-hidden=true href=#chap-6-synchronization>#</a></h3><h4 id=race-condition>Race condition<a hidden class=anchor aria-hidden=true href=#race-condition>#</a></h4><p>多個 process 同時使用共享變數，則可能導致共享變數最終值可能會因為 process 之間的交錯執行而有不同之結果。
·</p><ol><li>Mutual Exclusion(互斥)：有 process 在 critical section 裡面其他 prcoess 就不可以進去。</li><li>Progress(前進)：沒有 process 在 critical section 裡面時，而且有 process 想進 critical section，必須在有限時間內決定誰可以進去，不可造成所有 process 都進不去。</li><li>Bounded Waiting(有限等待)：在一個 process 發出進入 critical section 請求之後，且在該請求被允許之前，其他 process 進入其 critical section 的次數必須有一個限制</li></ol><h4 id=軟體>軟體<a hidden class=anchor aria-hidden=true href=#軟體>#</a></h4><ol><li>Peterson 解決方式(2 processes)</li><li>Bakery Algorithm(N prcoesses Peterson)</li></ol><h4 id=硬體>硬體<a hidden class=anchor aria-hidden=true href=#硬體>#</a></h4><ol><li>memory barries:memory 內容改變必須讓 prcoessors 知道</li><li>HW instructions:系統直接提供具有 Atomic 特性的指令，讓程式碼可以在單一時間點被完成，且不會中途被插斷。(Atomically Executed:在單位時間內可以順利做完，不受任何中斷干擾)<ol><li>test-and-set</li><li>swap</li></ol></li></ol><h4 id=mutex-locks互斥鎖spinlock>Mutex locks(互斥鎖)(spinlock)<a hidden class=anchor aria-hidden=true href=#mutex-locks互斥鎖spinlock>#</a></h4><p>在進入臨界區之前先獲得 Mutex locks，離開臨界區時再釋放 Mutex locks 即可</p><h4 id=semaphore號誌>Semaphore(號誌)<a hidden class=anchor aria-hidden=true href=#semaphore號誌>#</a></h4><p>用來解決 C.S. Design 及同歩問題的一種資料型態。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  wait(S) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span> (S <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>      S<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  signal(S) {
</span></span><span style=display:flex><span>      S<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h3 id=chap-8-deadlock>chap 8 Deadlock<a hidden class=anchor aria-hidden=true href=#chap-8-deadlock>#</a></h3><h4 id=deadlock-def>Deadlock def<a hidden class=anchor aria-hidden=true href=#deadlock-def>#</a></h4><p>系統中存在一組 process 陷入互相等待對方所擁有的資源的情況，造成所有的 process 無法往下執行，使得 CPU 利用度大幅降低。</p><h4 id=死結四個必要條件>死結四個必要條件<a hidden class=anchor aria-hidden=true href=#死結四個必要條件>#</a></h4><blockquote><p>少一死結不成立</p></blockquote><ol><li>互斥(Mutual exclusion)：一次只有一個 process 可以使用此資源</li><li>擁有與等待(Hold and wait)：擁有至少一個資源的 process 正在等待獲取其他 process 所擁有的其他資源</li><li>不能強佔(No preemption)：擁有此資源的 process 完成工作後，才自動將此資源釋放出來</li><li>循環等待(Circular wait)：系統中存在一組 processes {P0,P1,…,Pn}，其中 P0 等待 P1 所持有的資源&mldr;Pn 等待 P0 所持有的資源，形成循環式等待。</li></ol><h4 id=資源分配圖>資源分配圖<a hidden class=anchor aria-hidden=true href=#資源分配圖>#</a></h4><blockquote><p>有圈圈有可能有死結，如果每一種資源型態都只有一個設備，則一定產生死結，複數個設備，則不一定會產生死結。沒圈圈沒有死結</p></blockquote><ol><li>請求邊(request edge)：有向邊 Pi->Rj 代表 proceess Pi 對資源型態 Rj 的設備發出使用請求</li><li>分配邊(assignment edge)：有向邊 Rj->Pi 代表資源型態 Rj 的一項設備已經分配給 process Pi</li></ol><h4 id=死結處理方法>死結處理方法<a hidden class=anchor aria-hidden=true href=#死結處理方法>#</a></h4><ol><li><p>死結預防(deadlock prevention):讓四個必要條件至少有一個不成立</p><ul><li><p>互斥(Mutual exclusion):但對不可共享的資源則一定成立，通常 read only file 是分享式資源</p></li><li><p>擁有與等待(Hold and wait):</p><ul><li>除非 process 可以一次取得所有工作所需的資源，才允許持有資源</li><li>process 執行之初可持有部分資源，但要再申請資源前，要先釋放手中所有資源</li></ul></li><li><p>缺點:資源使用率低、可能發生 starvation</p><ul><li>不能強佔(No preemption):讓 process 手上的資源是允許被其它程式搶走的</li><li>循環等待(Circular wait):將所有資源型態作一順序性的編號，並要求所有行程依遞增(減)方式來請求資源</li></ul></li></ul></li><li><p>死結避免(deadlock avoidance):
最簡單及最有用的作法，即要求每一行程提供它所需要的各種資源型態的最大需求量(maximum number)死結避免演算法將動態檢驗資源分配狀態，確保循環等待(circular-wait)的條件不會發生資源分配狀態是由資源的可用量、已分配量、及 process 最大需求量來定義。</p><ul><li>safe state：
當程式提出資源的申請時，透過一個叫做「Banker&rsquo;s algorithm」的演算法檢查程式是否會進入「unsafe state」，safe state 是絕對不可能發生 deadlock 的情形，unsafe state 是有可能發生 deadlock 的情形，若允許程式提出資源的申請會進入「unsafe state」，便拒絕該程式的申請。</li></ul></li></ol><h4 id=死結避免演算法>死結避免演算法<a hidden class=anchor aria-hidden=true href=#死結避免演算法>#</a></h4><ol><li><p>銀行家演算法 (Banker&rsquo;s algorithm)</p><ul><li><p>資料結構:</p><ul><li><p>可用資源陣列(Available)</p></li><li><p>最大需求陣列(Max)</p></li><li><p>已分配陣列(Allocation)</p></li><li><p>剩餘需求陣列(Need)need = max-allocation</p><blockquote><ol><li>request&lt;=need 成立 goto2.</li><li>request&lt;=available 成立 goto3</li><li>available = available - request
allocation = allocation + request
need = need - request 成立 goto4</li></ol></blockquote></li><li><p>執行 safety algo</p><blockquote><p>新增資料結構:
Work
Finish
求出一個安全的序列</p></blockquote></li></ul></li></ul></li><li><p>資源分配圖形演算法 (Resource-allocation-graph algorithm)</p></li><li><p>死結偵測與回復(deadlock detection & recovery)</p></li></ol><h3 id=chap9-main-memory>chap9 Main Memory<a hidden class=anchor aria-hidden=true href=#chap9-main-memory>#</a></h3><ul><li><p>base 與 limit 暫存器可用來界定 address space</p><p>程式指令、資料與記憶體的位址連結(address binding)(決定 process 執行在 memory 之起始位置)可以發生在 3 個不同的階段：</p><ol><li>編譯時期(Compile time)：如果記憶體的位置是已知，編譯器產生具絕對位址的絕對碼(absolute code)，往後如果位置改變，則程式需重新編譯(recompile)</li><li>載入時期(Load time)：如果記憶體的位置為未知，則編譯器需產生可重定位之程式碼(relocatable code)</li><li>執行時期(Execution time)：若行程在執行期間會從記憶體的某一區段(segment)移至另一區段時，則位址連結將延後至執行時期處理。(base 與 limit 暫存器)</li></ol></li></ul><h4 id=邏輯位址logical-address>邏輯位址(Logical address)<a hidden class=anchor aria-hidden=true href=#邏輯位址logical-address>#</a></h4><p>CPU 所產生的位址稱之，也叫做虛擬位址(virtual address)</p><h4 id=實體位址physical-address>實體位址(Physical address)<a hidden class=anchor aria-hidden=true href=#實體位址physical-address>#</a></h4><p>記憶體單元所看到的位址，真正記憶體的位置(就是載入到記憶體位址暫存器(MAR)之地址)</p><blockquote><p>程式執行時虛擬(邏輯)位址與實體位址的 mapping，需藉由記憶體管理單元(Memory-Management Unit，MMU)的硬體來完成</p></blockquote><ul><li><p>dynamic loading(動態載入)：常式(routine)通常是在被呼叫時才載入</p><ul><li>優點:為了讓記憶體空間做最好的利用</li><li>缺點:較不具效率
(不需要 OS support)</li></ul></li><li><p>Dynamic linking(動態鏈結)：類似動態載入，且將鏈結延後至執行時間</p><ul><li>優點:也叫 shared library，因為 library 可以共用
(需要 OS support)</li></ul></li><li><p>先做 linking 再做 loading，所以 loading 前一定會先有 linking。linking 顧名思義就是與其他東西做連結，像是與 library 或者你程式有使用到別的程式的部分。</p></li><li><p>Dynamic loading 的目標是“函式沒有用到就不要 load”，Dynamic linking 的目標 則是防止重複 load library。</p></li><li><p>前者未必能防止重複，而後者需要檢查其他 process space，所以需要 OS 才能做到。</p></li><li><p>連續記憶體配置(contiguous allocation):因為 process 載入到 memory 執行，需要一塊連續的 memory space</p></li></ul><h4 id=memory-protect>memory protect<a hidden class=anchor aria-hidden=true href=#memory-protect>#</a></h4><ul><li>base register 包含最小物理地址的值</li><li>limit register 包含邏輯地址範圍，每個邏輯地址必須小於 limit register</li></ul><h4 id=memory-allocation>memory allocation<a hidden class=anchor aria-hidden=true href=#memory-allocation>#</a></h4><ul><li><p>多重分區 (Multiple-partition)分配:</p><ul><li>partition:(因為 process 載入到 memory 執行，需要一塊連續的 memory space)，即是 process 數目</li><li>partition size:也稱 varaiable partition，因為每個 process 大小不同</li><li>hole:process 多次的配置與釋放後，會有一些空間 free</li></ul></li><li><p>如何從 list of free holes 找出滿足記憶體大小需求為 n 的請求?</p><ol><li>First-fit:分配第一個夠大的 hole 給 process</li><li>Best-fit:在足夠大的 hole 裡面找出最小的 hole</li><li>Worst-fit:在足夠大的 hole 給他最大的 hole
1 ,2 > 3
但連續記憶體配置會遭遇一個問題：External Fragmentation</li></ol></li></ul><h4 id=fragmentation碎裂>Fragmentation(碎裂)<a hidden class=anchor aria-hidden=true href=#fragmentation碎裂>#</a></h4><ol><li>External Fragmentation(外部碎裂):memory space 加起來夠大，但卻不連續，導致無法分配</li><li>Internal Fragmentation(內部碎裂):分配的 memory space 比實際需求還大所造成的浪費，且這些空間不能再被使用</li></ol><ul><li><p>解決外碎</p><ol><li>compation(壓縮)</li><li>paging(分頁)</li></ol></li></ul><h4 id=paging>paging<a hidden class=anchor aria-hidden=true href=#paging>#</a></h4><ol><li>對實體位址空間採用非連續性配置</li><li>解決外碎，但還是有內碎</li></ol><h4 id=page-table-太大或建構方法>page table 太大或建構方法<a hidden class=anchor aria-hidden=true href=#page-table-太大或建構方法>#</a></h4><ol><li>Multilevel paging</li><li>Hashing Page Table</li><li>Invert Page Table</li></ol><h3 id=chap-10-virtual-memory>chap 10 Virtual Memory<a hidden class=anchor aria-hidden=true href=#chap-10-virtual-memory>#</a></h3><h4 id=vm>VM<a hidden class=anchor aria-hidden=true href=#vm>#</a></h4><p>一種允許行程執行時，不須完全載入記憶體的做法</p><blockquote><p>優點：程式可以大於實體記憶體
logical address space 可以大過 physical address space
缺點:不容易實作，可能會降低效能</p></blockquote><ol><li>邏輯位址空間可以遠大於實體記憶體空間</li><li>multiprogramming degree 增加</li><li>I/O time 減少</li></ol><h4 id=實作-vm>實作 VM<a hidden class=anchor aria-hidden=true href=#實作-vm>#</a></h4><ol><li><p>需求分頁(Demand paging)：於實際需要時才載入 pages</p><ul><li>在分頁表中每一項目均有一個有效/無效位元(valid/invalid bit)
(v 表分頁在記憶體內，i 表分頁不在記憶體內)</li><li>當分頁不在記憶體內時(bit = i)，發生 page fault</li></ul></li><li><p>需求分段(Demand segmentation)：於實際需要時才載入 segmentation</p></li></ol><h4 id=page-fault-handling>page fault handling<a hidden class=anchor aria-hidden=true href=#page-fault-handling>#</a></h4><ol><li>決定是否為合法/非法的記憶體存取</li><li>非法:終止這個 process，合法:page 不再記憶體</li><li>尋找可用頁框(free frame)</li><li>讀取 page 到可用頁框</li><li>修改 page table</li><li>重新執行導致 page fault 的指令</li></ol><h4 id=分頁有效存取時間-effective-access-time-之計算>分頁有效存取時間 (Effective Access Time) 之計算<a hidden class=anchor aria-hidden=true href=#分頁有效存取時間-effective-access-time-之計算>#</a></h4><blockquote><p>EAT = (1-p) <em>Memory Access Time + p</em> (Page fault process time)
p 是 page fault ratio.
例:
page fault ratio = 20%，
Memory Access Time=100ns,
Page fault process time = 5ns
=>(1-0.2)<em>100 + 0.2</em>5 = 9</p></blockquote><h4 id=page-replacement-algo>page replacement algo<a hidden class=anchor aria-hidden=true href=#page-replacement-algo>#</a></h4><ol><li>FIFO</li><li>OPT</li><li>LRU</li></ol><ul><li>Belady&rsquo;s anomaly：分配給 process 的頁框數增加，理應 page fault 次數應該降低，但 page fault ratio 卻不減反升</li></ul><h4 id=thrashing振盪>Thrashing(振盪)<a hidden class=anchor aria-hidden=true href=#thrashing振盪>#</a></h4><p>當 CPU 效能低時，系統會想引入更多的 process 讓 CPU 盡可能地工作(multiprogramming degree)。但當存有太多 process 時，大部分的工作將會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 的效能越來越低。</p><ul><li>方法<ol><li>降低 Multiprogramming Degree。</li><li>利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。</li><li>利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數，以防止 Thrashing。</li></ol></li></ul><h4 id=copy-on-write>copy-on-write<a hidden class=anchor aria-hidden=true href=#copy-on-write>#</a></h4><p>OS 會配置一個 new frame 給 child，將 page 內容 copy 一份到 new frame，修改 child 之 page table 指向 new frame 後，child 才進行 write 動作。</p><ul><li>優點：減少記憶體占用、增加 process 的 creation 速度</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://forshu.com/tags/os/>OS</a></li><li><a href=https://forshu.com/tags/note/>NOTE</a></li></ul><nav class=paginav><a class=prev href=https://forshu.com/posts/001/><span class=title>« Prev Page</span><br><span>My First Post</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share OS_FinalExam 筆記 on twitter" href="https://twitter.com/intent/tweet/?text=OS_FinalExam%20%e7%ad%86%e8%a8%98&url=https%3a%2f%2fforshu.com%2fposts%2f003%2f&hashtags=OS%2cNOTE"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share OS_FinalExam 筆記 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fforshu.com%2fposts%2f003%2f&title=OS_FinalExam%20%e7%ad%86%e8%a8%98&summary=OS_FinalExam%20%e7%ad%86%e8%a8%98&source=https%3a%2f%2fforshu.com%2fposts%2f003%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share OS_FinalExam 筆記 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fforshu.com%2fposts%2f003%2f&title=OS_FinalExam%20%e7%ad%86%e8%a8%98"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share OS_FinalExam 筆記 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fforshu.com%2fposts%2f003%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share OS_FinalExam 筆記 on whatsapp" href="https://api.whatsapp.com/send?text=OS_FinalExam%20%e7%ad%86%e8%a8%98%20-%20https%3a%2f%2fforshu.com%2fposts%2f003%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share OS_FinalExam 筆記 on telegram" href="https://telegram.me/share/url?text=OS_FinalExam%20%e7%ad%86%e8%a8%98&url=https%3a%2f%2fforshu.com%2fposts%2f003%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://cdn.jsdelivr.net/npm/@waline/client></script><div id=waline></div><script>new Waline({el:"#waline",serverURL:"https://m.bore.vip/",copyright:!0,login:"enable",placeholder:"歡迎評論",dark:".dark",requiredMeta:["nick","mail"]})</script></article></main><footer class=footer><span>&copy; 2022 <a href=https://forshu.com>Shu's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>